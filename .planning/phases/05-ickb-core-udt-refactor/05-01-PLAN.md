---
phase: 05-ickb-core-udt-refactor
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - pnpm-workspace.yaml
  - packages/core/package.json
  - packages/core/src/udt.ts
  - packages/core/src/logic.ts
  - packages/core/src/owned_owner.ts
autonomous: true
requirements:
  - SMTX-05
  - SMTX-07
  - SMTX-10
  - UDT-04

must_haves:
  truths:
    - "IckbUdt extends udt.Udt exists in @ickb/core with infoFrom override"
    - "infoFrom correctly values xUDT cells (positive), receipt cells (positive, input only), deposit cells (negative, input only)"
    - "IckbUdt.addCellDeps adds individual code deps (xUDT + Logic OutPoints), not dep group"
    - "IckbUdt.typeScriptFrom static method computes iCKB UDT type script"
    - "LogicManager no longer takes udtHandler parameter"
    - "OwnedOwnerManager no longer takes udtHandler parameter"
    - "No tx.addCellDeps(this.udtHandler.cellDeps) calls remain in LogicManager or OwnedOwnerManager"
  artifacts:
    - path: "packages/core/src/udt.ts"
      provides: "IckbUdt class extending udt.Udt with infoFrom, addCellDeps, typeScriptFrom"
      contains: "class IckbUdt extends udt.Udt"
    - path: "packages/core/src/logic.ts"
      provides: "LogicManager without udtHandler parameter"
    - path: "packages/core/src/owned_owner.ts"
      provides: "OwnedOwnerManager without udtHandler parameter"
    - path: "packages/core/package.json"
      provides: "@ckb-ccc/udt dependency"
      contains: "@ckb-ccc/udt"
    - path: "pnpm-workspace.yaml"
      provides: "Catalog entry for @ckb-ccc/udt"
      contains: "@ckb-ccc/udt"
  key_links:
    - from: "packages/core/src/udt.ts"
      to: "@ckb-ccc/udt"
      via: "import { udt } from '@ckb-ccc/udt'"
      pattern: "import.*udt.*from.*@ckb-ccc/udt"
    - from: "packages/core/src/udt.ts"
      to: "packages/core/src/entities.ts"
      via: "ReceiptData.decode for receipt cell valuation"
      pattern: "ReceiptData\\.decode"
    - from: "packages/core/src/udt.ts"
      to: "@ickb/dao"
      via: "DaoManager for deposit cell identification"
      pattern: "daoManager\\.isDeposit"
---

<objective>
Implement IckbUdt class extending CCC's udt.Udt in @ickb/core, replacing IckbUdtManager. Remove udtHandler parameter from LogicManager and OwnedOwnerManager. Add @ckb-ccc/udt dependency.

Purpose: This is the core CCC UDT integration -- IckbUdt.infoFrom provides accurate multi-representation balance (xUDT + receipts + deposits) consumed by CCC's completeInputsByBalance pipeline. Removing udtHandler from managers follows the Phase 4 OrderManager pattern, making UDT cellDeps a caller responsibility.

Output: Modified core/src/udt.ts (IckbUdt class), modified logic.ts and owned_owner.ts (no udtHandler), updated package.json and catalog.
</objective>

<execution_context>
@/home/node/.claude/get-shit-done/workflows/execute-plan.md
@/home/node/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-ickb-core-udt-refactor/05-CONTEXT.md
@.planning/phases/05-ickb-core-udt-refactor/05-RESEARCH.md

<interfaces>
<!-- Key types and contracts the executor needs. Extracted from codebase. -->

From @ckb-ccc/udt (CCC Udt class -- the base class to extend):
```typescript
import { udt } from "@ckb-ccc/udt";

// Constructor: (code: OutPointLike, script: ScriptLike, config?: UdtConfigLike | null)
// - code: xUDT code cell OutPoint (passed to ssri.Trait)
// - script: iCKB UDT type script (token identity)
// No executor needed (legacy xUDT, not SSRI)

class Udt extends ssri.Trait {
  public readonly script: ccc.Script;
  public readonly filter: ccc.ClientIndexerSearchKeyFilter;

  constructor(code: ccc.OutPointLike, script: ccc.ScriptLike, config?: UdtConfigLike | null);

  // Override this for multi-representation balance
  async infoFrom(
    _client: ccc.Client,
    cells: ccc.CellAnyLike | ccc.CellAnyLike[],
    acc?: UdtInfoLike,
  ): Promise<UdtInfo>;

  // Override this for custom cellDeps
  addCellDeps(txLike: ccc.TransactionLike): ccc.Transaction;

  // Checks cell.type matches this.script AND outputData >= 16 bytes
  isUdt(cell: ccc.CellAnyLike): boolean;

  // Extracts balance from outputData (LE uint128)
  static balanceFromUnsafe(outputData: ccc.HexLike): ccc.Num;
}

class UdtInfo {
  balance: ccc.Num;
  capacity: ccc.Num;
  count: number;
  static from(infoLike?: UdtInfoLike): UdtInfo;
  clone(): UdtInfo;
  addAssign(infoLike: UdtInfoLike): this;
}
```

From packages/core/src/udt.ts (BEFORE -- current IckbUdtManager to replace):
```typescript
export class IckbUdtManager extends UdtManager implements UdtHandler {
  constructor(
    script: ccc.Script,
    cellDeps: ccc.CellDep[],
    public readonly logicScript: ccc.Script,
    public readonly daoManager: DaoManager,
  ) { super(script, cellDeps, "iCKB", "iCKB", 8); }

  static calculateScript(udt: ccc.Script, ickbLogic: ccc.Script): ccc.Script;
  override async getInputsUdtBalance(client, txLike): Promise<[FixedPoint, FixedPoint]>;
}

// These functions/constants MUST be preserved unchanged:
export function ickbValue(ckbUnoccupiedCapacity, header): FixedPoint;
export function convert(isCkb2Udt, amount, rate, accountDepositCapacity?): FixedPoint;
export function ickbExchangeRatio(header, accountDepositCapacity?): ExchangeRatio;
export const ICKB_DEPOSIT_CAP;
// Internal constants (AR_0, depositUsedCapacity, depositCapacityDelta) also preserved
```

From packages/core/src/entities.ts:
```typescript
export const ReceiptData = {
  decode(data: ccc.HexLike): { depositQuantity: bigint; depositAmount: bigint };
  encode(data: { depositQuantity: number; depositAmount: bigint }): ccc.Hex;
};
```

From @ickb/dao:
```typescript
export class DaoManager {
  isDeposit(cell: ccc.Cell): boolean;  // Checks outputData for 8 zero bytes
}
```

From packages/core/src/logic.ts (BEFORE -- udtHandler to remove):
```typescript
export class LogicManager implements ScriptDeps {
  constructor(
    public readonly script: ccc.Script,
    public readonly cellDeps: ccc.CellDep[],
    public readonly daoManager: DaoManager,
    public readonly udtHandler: UdtHandler,  // REMOVE
  ) {}
  // Line 88: tx.addCellDeps(this.udtHandler.cellDeps);  // REMOVE (in deposit)
  // Line 125: tx.addCellDeps(this.udtHandler.cellDeps);  // REMOVE (in completeDeposit)
}
```

From packages/core/src/owned_owner.ts (BEFORE -- udtHandler to remove):
```typescript
export class OwnedOwnerManager implements ScriptDeps {
  constructor(
    public readonly script: ccc.Script,
    public readonly cellDeps: ccc.CellDep[],
    public readonly daoManager: DaoManager,
    public readonly udtHandler: UdtHandler,  // REMOVE
  ) {}
  // Line 95: tx.addCellDeps(this.udtHandler.cellDeps);  // REMOVE (in requestWithdrawal)
  // Line 140: tx.addCellDeps(this.udtHandler.cellDeps);  // REMOVE (in withdraw)
}
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add @ckb-ccc/udt dependency and implement IckbUdt class</name>
  <files>pnpm-workspace.yaml, packages/core/package.json, packages/core/src/udt.ts</files>
  <action>
**Step 1: Add catalog entry in `pnpm-workspace.yaml`**

Add `"@ckb-ccc/udt": ^1.12.2` to the catalog section, after the existing `"@ckb-ccc/core": ^1.12.2` entry. This ensures consistency with how `@ckb-ccc/core` is referenced. The `.pnpmfile.cjs` hook will rewrite to `workspace:*` when the local CCC fork is present.

**Step 2: Add dependency in `packages/core/package.json`**

Add `"@ckb-ccc/udt": "catalog:"` to the dependencies object, after `"@ckb-ccc/core": "catalog:"`. The dependencies section should become:
```json
"dependencies": {
  "@ckb-ccc/core": "catalog:",
  "@ckb-ccc/udt": "catalog:",
  "@ickb/dao": "workspace:*",
  "@ickb/utils": "workspace:*"
}
```

**Step 3: Run `pnpm install` to update lockfile**

**Step 4: Rewrite `packages/core/src/udt.ts`**

Replace the entire `IckbUdtManager` class with `IckbUdt extends udt.Udt`. Keep all standalone functions (`ickbValue`, `convert`, `ickbExchangeRatio`) and constants (`ICKB_DEPOSIT_CAP`, `AR_0`, `depositUsedCapacity`, `depositCapacityDelta`) UNCHANGED.

New imports (replacing current imports):
```typescript
import { ccc } from "@ckb-ccc/core";
import { udt } from "@ckb-ccc/udt";
import { ReceiptData } from "./entities.js";
import type { DaoManager } from "@ickb/dao";
import type { ExchangeRatio } from "@ickb/utils";
```

Note: `UdtManager` and `UdtHandler` imports are removed. `ExchangeRatio` is kept (used by `convert` function). `udt` namespace import is added from `@ckb-ccc/udt`.

New class definition:
```typescript
/**
 * IckbUdt extends CCC's Udt class to provide accurate multi-representation
 * balance for iCKB tokens. The iCKB conservation law is:
 *   Input UDT + Input Receipts = Output UDT + Input Deposits
 *
 * `infoFrom` values three cell types:
 * - xUDT cells: positive balance (standard UDT)
 * - Receipt cells: positive balance (input only, valued via ickbValue)
 * - Deposit cells: negative balance (input only, withdrawal reduces UDT supply)
 *
 * Output cells without outPoint are naturally excluded from receipt/deposit
 * processing, since only input cells (resolved by CellInput.getCell()) have outPoint.
 */
export class IckbUdt extends udt.Udt {
  public readonly logicCode: ccc.OutPoint;
  public readonly logicScript: ccc.Script;
  public readonly daoManager: DaoManager;

  /**
   * Creates an instance of IckbUdt.
   *
   * @param code - The xUDT code cell OutPoint (passed to base Udt/Trait).
   * @param script - The iCKB UDT type script (token identity via args).
   * @param logicCode - The iCKB Logic code cell OutPoint.
   * @param logicScript - The iCKB Logic script.
   * @param daoManager - The DAO manager instance for deposit cell identification.
   */
  constructor(
    code: ccc.OutPointLike,
    script: ccc.ScriptLike,
    logicCode: ccc.OutPointLike,
    logicScript: ccc.ScriptLike,
    daoManager: DaoManager,
  ) {
    super(code, script);
    this.logicCode = ccc.OutPoint.from(logicCode);
    this.logicScript = ccc.Script.from(logicScript);
    this.daoManager = daoManager;
  }

  /**
   * Computes the iCKB UDT type script from raw UDT and Logic scripts.
   *
   * Concatenates the iCKB logic script hash with a fixed 4-byte LE length
   * postfix ("00000080") to form the UDT type script args.
   *
   * @param udt - The raw xUDT script (codeHash and hashType reused).
   * @param ickbLogic - The iCKB logic script (hash used for args).
   * @returns A new Script with the computed args.
   */
  static typeScriptFrom(udt: ccc.Script, ickbLogic: ccc.Script): ccc.Script {
    const { codeHash, hashType } = udt;
    return new ccc.Script(
      codeHash,
      hashType,
      [ickbLogic.hash(), "00000080"].join("") as ccc.Hex,
    );
  }

  /**
   * Computes UDT balance info for iCKB's three cell representations.
   *
   * For each cell:
   * - xUDT cell (type === this.script, data >= 16 bytes): adds positive balance
   * - Receipt cell (type === logicScript, has outPoint): adds positive balance
   *   via ickbValue of deposit amount * quantity
   * - Deposit cell (lock === logicScript, isDeposit, has outPoint): adds negative
   *   balance via ickbValue of free capacity (withdrawal reduces UDT supply)
   *
   * Cells without outPoint (output cells from getOutputsInfo) skip receipt/deposit
   * processing -- correct by design since these only appear as inputs.
   *
   * @param client - CKB client for header fetches (receipt/deposit valuation).
   * @param cells - Cell or array of cells to evaluate.
   * @param acc - Optional accumulator for running totals.
   * @returns UdtInfo with balance, capacity, and count.
   */
  override async infoFrom(
    client: ccc.Client,
    cells: ccc.CellAnyLike | ccc.CellAnyLike[],
    acc?: udt.UdtInfoLike,
  ): Promise<udt.UdtInfo> {
    const info = udt.UdtInfo.from(acc).clone();

    for (const cellLike of [cells].flat()) {
      const cell = ccc.CellAny.from(cellLike);

      // Standard xUDT cell -- delegate to base class pattern
      if (this.isUdt(cell)) {
        info.addAssign({
          balance: udt.Udt.balanceFromUnsafe(cell.outputData),
          capacity: cell.cellOutput.capacity,
          count: 1,
        });
        continue;
      }

      // Receipt and deposit cells need outPoint for header fetch.
      // Output cells (no outPoint) are skipped -- correct by design.
      if (!cell.outPoint) {
        continue;
      }

      const { type, lock } = cell.cellOutput;

      // Receipt cell: type === logicScript
      if (type && this.logicScript.eq(type)) {
        const txWithHeader = await client.getTransactionWithHeader(
          cell.outPoint.txHash,
        );
        if (!txWithHeader?.header) {
          throw new Error("Header not found for txHash");
        }

        const { depositQuantity, depositAmount } =
          ReceiptData.decode(cell.outputData);
        info.addAssign({
          balance: ickbValue(depositAmount, txWithHeader.header) *
            depositQuantity,
          capacity: cell.cellOutput.capacity,
          count: 1,
        });
        continue;
      }

      // Deposit cell: lock === logicScript AND isDeposit
      if (this.logicScript.eq(lock) && this.daoManager.isDeposit(cell)) {
        const txWithHeader = await client.getTransactionWithHeader(
          cell.outPoint.txHash,
        );
        if (!txWithHeader?.header) {
          throw new Error("Header not found for txHash");
        }

        info.addAssign({
          balance: -ickbValue(cell.capacityFree, txWithHeader.header),
          capacity: cell.cellOutput.capacity,
          count: 1,
        });
        continue;
      }
    }

    return info;
  }

  /**
   * Adds iCKB-specific cell dependencies to a transaction.
   *
   * Adds individual code deps (not dep group) for:
   * - xUDT code cell (this.code from ssri.Trait)
   * - iCKB Logic code cell (this.logicCode)
   *
   * @param txLike - The transaction to add cell deps to.
   * @returns The transaction with cell deps added.
   */
  override addCellDeps(txLike: ccc.TransactionLike): ccc.Transaction {
    const tx = ccc.Transaction.from(txLike);
    // xUDT code dep
    tx.addCellDeps({ outPoint: this.code, depType: "code" });
    // iCKB Logic code dep
    tx.addCellDeps({ outPoint: this.logicCode, depType: "code" });
    return tx;
  }
}
```

**Key implementation notes:**
- `daoManager.isDeposit(cell)` receives a `CellAny` from `CellAny.from(cellLike)`. In `infoFrom` called from `getInputsInfo`, input cells are resolved via `CellInput.getCell()` which returns `Cell` (extends `CellAny`). `DaoManager.isDeposit` takes `ccc.Cell`, and `Cell extends CellAny`, so this works for input cells. For output cells, the `!cell.outPoint` check gates them before `isDeposit` is reached.
- `balance` in `UdtInfo` uses `ccc.Num` (bigint), which can go negative for deposit cells. This is intentional -- CCC's `completeInputsByBalance` checks `info.balance >= 0` to stop.
- The `ickbValue` call for receipt cells multiplies by `depositQuantity` (a receipt can represent multiple deposits).
- The `ickbValue` call for deposit cells uses `cell.capacityFree` (available via `CellAny.capacityFree` getter).

**PRESERVE all code below the class definition unchanged:**
- `ickbValue` function
- `ICKB_DEPOSIT_CAP` constant
- `convert` function
- `ickbExchangeRatio` function
- `AR_0`, `depositUsedCapacity`, `depositCapacityDelta` constants
  </action>
  <verify>
    <automated>cd /workspaces/stack && pnpm install && grep -q "@ckb-ccc/udt" pnpm-workspace.yaml && grep -q "@ckb-ccc/udt" packages/core/package.json && grep -q "class IckbUdt extends udt.Udt" packages/core/src/udt.ts && grep -q "typeScriptFrom" packages/core/src/udt.ts && echo "PASS"</automated>
  </verify>
  <done>
    - @ckb-ccc/udt added to pnpm-workspace.yaml catalog
    - @ckb-ccc/udt added to @ickb/core package.json dependencies
    - IckbUdt extends udt.Udt class exists with infoFrom, addCellDeps, typeScriptFrom
    - IckbUdtManager class no longer exists
    - calculateScript renamed to typeScriptFrom (static)
    - No imports of UdtManager or UdtHandler from @ickb/utils in core/src/udt.ts
    - All standalone functions and constants preserved unchanged
  </done>
</task>

<task type="auto">
  <name>Task 2: Remove udtHandler from LogicManager and OwnedOwnerManager</name>
  <files>packages/core/src/logic.ts, packages/core/src/owned_owner.ts</files>
  <action>
**In `packages/core/src/logic.ts`:**

1. Remove `type UdtHandler,` from the `@ickb/utils` import on line 6. Keep `defaultFindCellsLimit`, `type ScriptDeps`, `unique`.

2. Update JSDoc on line 29: remove `@param udtHandler - The handler for User Defined Tokens (UDTs).`

3. Remove constructor parameter on line 34: delete `public readonly udtHandler: UdtHandler,`

4. In `deposit()` method (line 88): delete `tx.addCellDeps(this.udtHandler.cellDeps);`
   Add JSDoc `@remarks` to deposit()'s existing JSDoc block: `@remarks Caller must ensure UDT cellDeps are added to the transaction (e.g., via ickbUdt.addCellDeps(tx)).`

5. In `completeDeposit()` method (line 125): delete `tx.addCellDeps(this.udtHandler.cellDeps);`
   Add JSDoc `@remarks` to completeDeposit()'s existing JSDoc block: `@remarks Caller must ensure UDT cellDeps are added to the transaction (e.g., via ickbUdt.addCellDeps(tx)).`

**In `packages/core/src/owned_owner.ts`:**

1. Remove `type UdtHandler,` from the `@ickb/utils` import on line 6. Keep `defaultFindCellsLimit`, `unique`, `type ScriptDeps`.

2. Update JSDoc on line 24: remove `@param udtHandler - The handler for User Defined Tokens (UDTs).`

3. Remove constructor parameter on line 29: delete `public readonly udtHandler: UdtHandler,`

4. In `requestWithdrawal()` method (line 95): delete `tx.addCellDeps(this.udtHandler.cellDeps);`
   Add JSDoc `@remarks` to requestWithdrawal()'s existing JSDoc block: `@remarks Caller must ensure UDT cellDeps are added to the transaction (e.g., via ickbUdt.addCellDeps(tx)).`

5. In `withdraw()` method (line 140): delete `tx.addCellDeps(this.udtHandler.cellDeps);`
   Add JSDoc `@remarks` to withdraw()'s existing JSDoc block: `@remarks Caller must ensure UDT cellDeps are added to the transaction (e.g., via ickbUdt.addCellDeps(tx)).`

This matches Phase 4's OrderManager pattern exactly. UDT cellDeps are now caller responsibility -- documented via JSDoc @remarks.
  </action>
  <verify>
    <automated>cd /workspaces/stack && ! grep -rq "UdtHandler\|udtHandler" packages/core/src/logic.ts packages/core/src/owned_owner.ts && echo "PASS"</automated>
  </verify>
  <done>
    - LogicManager constructor has 3 parameters (script, cellDeps, daoManager) -- no udtHandler
    - OwnedOwnerManager constructor has 3 parameters (script, cellDeps, daoManager) -- no udtHandler
    - All 4 tx.addCellDeps(this.udtHandler.cellDeps) calls deleted (2 in logic.ts, 2 in owned_owner.ts)
    - UdtHandler no longer imported in either file
    - JSDoc @remarks added to deposit(), completeDeposit(), requestWithdrawal(), withdraw() about caller cellDeps responsibility
  </done>
</task>

</tasks>

<verification>
1. `grep -q "class IckbUdt extends udt.Udt" packages/core/src/udt.ts` confirms IckbUdt class exists
2. `grep -q "typeScriptFrom" packages/core/src/udt.ts` confirms renamed static method
3. `grep -q "override async infoFrom" packages/core/src/udt.ts` confirms infoFrom override
4. `grep -q "override addCellDeps" packages/core/src/udt.ts` confirms addCellDeps override
5. `grep -r "UdtHandler\|udtHandler" packages/core/src/logic.ts packages/core/src/owned_owner.ts` returns no matches
6. `grep -r "UdtManager\|IckbUdtManager" packages/core/src/udt.ts` returns no matches (old class removed)
7. `grep -q "@ckb-ccc/udt" packages/core/package.json` confirms dependency added
8. `grep -q "@ckb-ccc/udt" pnpm-workspace.yaml` confirms catalog entry added
</verification>

<success_criteria>
- IckbUdt extends udt.Udt with infoFrom override for multi-representation balance
- addCellDeps override adds individual code deps (xUDT + Logic)
- typeScriptFrom static method replaces calculateScript
- LogicManager and OwnedOwnerManager no longer take udtHandler parameter
- All 4 udtHandler.cellDeps calls removed from managers
- @ckb-ccc/udt dependency added to core package.json and workspace catalog
- No imports of UdtManager, UdtHandler, or IckbUdtManager remain in @ickb/core
- All standalone functions (ickbValue, convert, ickbExchangeRatio) and constants preserved unchanged
</success_criteria>

<output>
After completion, create `.planning/phases/05-ickb-core-udt-refactor/05-01-SUMMARY.md`
</output>
