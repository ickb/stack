# AI Coworker Configuration

## Meta

- **Learn**: When a non-obvious constraint causes a failure, leave a concise note here and a detailed comment at the relevant location
- `CLAUDE.md` is a symlink to this file, created by `pnpm coworker`
- Refer to yourself as "AI Coworker" in docs and comments, not by product or company name
- Never add AI tool attribution or branding to PR descriptions, commit messages, or code comments
- Do not install or use `gh` CLI
- **Copy to clipboard**:

  ```sh
  head -c -1 <<'EOF' | wl-copy
  content goes here
  EOF
  ```

## PR Workflow

1. **Routine Pre-PR Validation**: `pnpm check:full`, it wipes derived state and regenerates from scratch. If `ccc-dev/ccc/` has pending work, the wipe is skipped to prevent data loss — re-record or push CCC changes first for a clean validation
2. **Open a PR**: Run `pnpm changeset` to generate a changeset entry, then push the branch and present a clickable markdown link `[title](url)` where the URL is a GitHub compare URL (`quick_pull=1`). Base branch is `master`. Prefill "title" (concise, under 70 chars) and "body" (markdown with ## Why and ## Changes sections)
3. **Fetch PR review comments**: Use the GitHub REST API via curl. Fetch all three comment types (issue comments, reviews, and inline comments). Reviewers reply asynchronously — poll every minute until comments arrive

## CCC Local Development (ccc-dev/)

The `ccc-dev/` system uses a record/replay mechanism for deterministic builds of a local CCC fork:

- `ccc-dev/pins/` is **committed** to git (base SHAs, merge refs, conflict resolutions, local patches), regenerated by `pnpm ccc:record`
- `ccc-dev/ccc/` is **not in git** — it is rebuilt from pins on `pnpm install`
- The developer may have **pending work** in `ccc-dev/ccc/`. Run `pnpm ccc:status` (exit 0 = safe to wipe, exit 1 = has custom work) before any operation that would destroy it. `pnpm ccc:record`, `pnpm ccc:clean`, and `pnpm ccc:reset` already guard against this automatically
- `.pnpmfile.cjs` silently rewrites all `@ckb-ccc/*` dependencies to `workspace:*` when `ccc-dev/ccc/` exists. Local CCC packages override published ones without any visible change in package.json files
- `pnpm install` has a side effect: if `ccc-dev/pins/REFS` exists but `ccc-dev/ccc/` does not, it automatically runs `ccc-dev/replay.sh` to rebuild CCC from pins. This is intentional
- `ccc-dev/patch.sh` rewrites CCC package exports to point at `.ts` source instead of `.d.ts`, then creates a deterministic git commit (fixed author/date) so record and replay produce the same `pins/HEAD` hash. This is why imports from `@ckb-ccc/*` resolve to TypeScript source files inside `node_modules` — it is not a bug
- `ccc-dev/tsgo-filter.sh` is a bash wrapper around `tsgo` that filters out diagnostics originating from `ccc-dev/ccc/`. CCC source does not satisfy this repo's strict tsconfig (`verbatimModuleSyntax`, `noUncheckedIndexedAccess`, `noImplicitOverride`), so the wrapper suppresses those errors while still reporting errors in stack source

### Opening a CCC upstream PR

In `ccc-dev/ccc/`, branch off `origin/master` (or relevant branch), push to fork (`phroi/ccc`), open PR against `ckb-devrel/ccc`. Before pushing, run the CCC CI steps (`ccc-dev/ccc/.github/workflows/check.yaml`) with `CI=true`.

Once the PR is open, replace the local patch with a merge ref:

1. Delete the patch from `ccc-dev/pins/local/`
2. Add the PR number to `ccc:record` in `package.json` — order PRs by target branch from upstream to downstream, so each group merges cleanly onto its base before the next layer begins
3. Run `pnpm ccc:record`
4. Run `pnpm check:full` to verify the merge ref reproduces what the local patch achieved

## Reference Repos

`reference/` contains read-only clones (project knowledge, dependency sources, etc.) fetched via `pnpm reference`. To refresh, just re-run `pnpm reference`. If a task requires knowledge of an external repo not yet cloned, add it to `reference/clone.sh` and run `pnpm reference` to fetch it for consultation

## Knowledge

- Always compare CKB scripts using full `Script.eq()` (codeHash + hashType + args), never just `codeHash`. Partial comparison silently matches wrong scripts
