# AI Coworker Configuration

## Meta

- **Learn**: When a non-obvious constraint causes a failure, leave a concise note here and a detailed comment at the relevant location
- `CLAUDE.md` is a symlink to this file, created by `pnpm coworker`
- Refer to yourself as "AI Coworker" in docs and comments, not by product or company name
- Never add AI tool attribution or branding to PR descriptions, commit messages, or code comments
- Do not install or use `gh` CLI
- When a post-plan fix changes a documented decision, update the planning docs in the same commit
- **Copy to clipboard**:

  ```sh
  head -c -1 <<'EOF' | wl-copy
  content goes here
  EOF
  ```

## PR Workflow

1. **Routine Pre-PR Validation**: `pnpm check:full`, it wipes derived state and regenerates from scratch. If `ccc-dev/ccc/` has pending work, the wipe is skipped to prevent data loss — re-record or push CCC changes first for a clean validation
2. **Open a PR**: Run `pnpm changeset` to generate a changeset entry, then push the branch and present a clickable markdown link `[title](url)` where the URL is a GitHub compare URL (`quick_pull=1`). Base branch is `master`. Prefill "title" (concise, under 70 chars) and "body" (markdown with ## Why and ## Changes sections)
3. **Fetch PR review comments**: Use the GitHub REST API via curl. Fetch all three comment types (issue comments, reviews, and inline comments). Categorize feedback by actionability (action required / informational), not by source (human / bot). Reviewers reply asynchronously — poll every minute until comments arrive

## CCC Local Development (ccc-dev/)

The `ccc-dev/` system uses a record/replay mechanism for deterministic builds of a local CCC fork:

- `ccc-dev/pins/` is **committed** to git (manifest + counted resolutions + local patches), regenerated by `pnpm ccc:record`
  - `pins/HEAD` — expected final SHA after full replay
  - `pins/manifest` — base SHA + merge refs (TSV, one per line)
  - `pins/res-N.resolution` — conflict resolution for merge step N (counted format: `--- path` file headers, `CONFLICT ours=N base=M theirs=K resolution=R` conflict headers followed by R resolution lines; parser is purely positional — reads counts and skips lines, never inspects content)
  - `pins/local-*.patch` — local development patches (applied after merges + patch.sh)
- `ccc-dev/ccc/` is **not in git** — it is rebuilt from pins on `pnpm install`
- The developer may have **pending work** in `ccc-dev/ccc/`. Run `pnpm ccc:status` (exit 0 = safe to wipe, exit 1 = has custom work) before any operation that would destroy it. `pnpm ccc:record`, `pnpm ccc:clean`, and `pnpm ccc:reset` already guard against this automatically
- `.pnpmfile.cjs` silently rewrites all `@ckb-ccc/*` dependencies to `workspace:*` when `ccc-dev/ccc/` exists. Local CCC packages override published ones without any visible change in package.json files
- `pnpm install` has a side effect: if `ccc-dev/pins/manifest` exists but `ccc-dev/ccc/` does not, it automatically runs `ccc-dev/replay.sh` to rebuild CCC from pins. This is intentional
- `ccc-dev/patch.sh` rewrites CCC package exports to point at `.ts` source instead of `.d.ts`, then creates a deterministic git commit (fixed author/date) so record and replay produce the same HEAD hash. This is why imports from `@ckb-ccc/*` resolve to TypeScript source files inside `node_modules` — it is not a bug
- `ccc-dev/tsgo-filter.sh` is a bash wrapper around `tsgo` that filters out diagnostics originating from `ccc-dev/ccc/`. CCC source does not satisfy this repo's strict tsconfig (`verbatimModuleSyntax`, `noUncheckedIndexedAccess`, `noImplicitOverride`), so the wrapper suppresses those errors while still reporting errors in stack source
- `pnpm ccc:save [description]` captures local work as a patch in `pins/`. Patches survive re-records and replays

### CCC upstream contributions

Work locally via `ccc-dev/` first. Only push to the fork (`phroi/ccc`) when changes are validated against the stack. Do not open PRs against `ckb-devrel/ccc` prematurely — keep changes on the fork until they are production-ready and the maintainer decides to upstream.

1. Develop and test in `ccc-dev/ccc/` on the `wip` branch
2. When ready, use `pnpm ccc:push` to cherry-pick commits onto a PR branch
3. Push the PR branch to `phroi/ccc` for review
4. Add the PR number to `ccc:record` in `package.json` — order PRs by target branch from upstream to downstream, so each group merges cleanly onto its base before the next layer begins
5. Run `pnpm ccc:record` and `pnpm check:full` to verify
6. Only open an upstream PR against `ckb-devrel/ccc` when the maintainer explicitly decides to upstream

## Reference Repos

`reference/` contains read-only clones (project knowledge, dependency sources, etc.) fetched via `pnpm reference`. To refresh, just re-run `pnpm reference`. If a task requires knowledge of an external repo not yet cloned, add it to `reference/clone.sh` and run `pnpm reference` to fetch it for consultation

## Knowledge

- Always compare CKB scripts using full `Script.eq()` (codeHash + hashType + args), never just `codeHash`. Partial comparison silently matches wrong scripts
